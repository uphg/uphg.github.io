import{_ as n,C as s,c as p,o as c,ag as l,G as a,j as e,a as t}from"./chunks/framework.BHpayLOB.js";const q=JSON.parse('{"title":"正则表达式入门","description":"","frontmatter":{"title":"正则表达式入门","tags":["regex"],"date":"2021-02-12T10:15:22.000Z","prev":{"text":"堆叠上下文","link":"/post/stacking-context"},"next":{"text":"DOM 操作跨线程","link":"/post/dom-operate-across-threads"}},"headers":[],"relativePath":"post/regexp-started.md","filePath":"post/regexp-started.md","lastUpdated":1714895308000}'),r={name:"post/regexp-started.md"};function i(u,d,b,g,x,h){const o=s("t-regexp-demo");return c(),p("div",null,[d[0]||(d[0]=l('<h2 id="相关链接" tabindex="-1">相关链接 <a class="header-anchor" href="#相关链接" aria-label="Permalink to &quot;相关链接&quot;">​</a></h2><ul><li>内容参考：<a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noreferrer">正则表达式30分钟入门教程</a></li><li>正则验证：<a href="https://deerchao.cn/tools/wegester/" target="_blank" rel="noreferrer">在线正则验证器(JavaScript)</a></li></ul><h2 id="入门" tabindex="-1">入门 <a class="header-anchor" href="#入门" aria-label="Permalink to &quot;入门&quot;">​</a></h2><p><code>\\b</code> 是正则表达式规定的一个特殊代码（元字符），代表着单词的开头或结尾，也就是单词的分界处。</p><blockquote><p>如果需要更精确的说法，<code>\\b</code> 匹配这样的位置：它的前一个字符和后一个字符不全是（一个是,一个不是或不存在）<code>\\w</code>。</p></blockquote><p>假如要精确地查找 hi 这个单词，如下</p>',6)),a(o,{text:"him, hi, history, high",regex:"\\bhi\\b"}),d[1]||(d[1]=e("p",null,"假如要找 hi 后面不远处跟着的一个 Lucy 的内容，如下",-1)),a(o,{text:"him, hi, reset, Lucy, high",regex:"\\bhi\\b.*\\bLucy\\b"}),d[2]||(d[2]=e("p",null,[e("code",null,"."),t(" 是另一个元字符，匹配"),e("strong",null,"除了换行符以外的任意字符"),t("。")],-1)),d[3]||(d[3]=e("p",null,[e("code",null,"*"),t(" 同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定 "),e("code",null,"*"),t(),e("strong",null,"前边的内容可以连续重复使用任意次以使整个表达式得到匹配"),t("。")],-1)),d[4]||(d[4]=e("p",null,"将元字符与其他字符组合起来，就可以组成更强大的正则表达式，如下",-1)),a(o,{text:`012-34567890
123-45678901`,regex:"0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d"}),d[5]||(d[5]=e("p",null,[t("这里的 "),e("code",null,"\\d"),t(" 是个新的元字符，匹配一位数字（0，或1，或2，或…）。")],-1)),d[6]||(d[6]=e("p",null,[t("为了避免多次重复，可以使用 "),e("code",null,"{}"),t(" 简写上面的正则，如下")],-1)),a(o,{text:`012-34567890
123-45678901`,regex:"0\\d{2}-\\d{8}"}),d[7]||(d[7]=l('<h2 id="元字符" tabindex="-1">元字符 <a class="header-anchor" href="#元字符" aria-label="Permalink to &quot;元字符&quot;">​</a></h2><p>现在你已经知道几个有用的元字符了（<code>\\b</code>、<code>.</code>、<code>*</code>，还有 <code>\\d</code>），正则表达式还有很多元字符，如：</p><ul><li><code>\\s</code> 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</li><li><code>\\w</code> 匹配字母、数字或下划线。</li></ul><p>下面来看看更多的例子：</p><p><code>\\ba\\w*\\b</code> 匹配以字母 a 开头的单词</p>',5)),a(o,{text:"animation, transition, all, family",regex:"\\ba\\w*\\b"}),d[8]||(d[8]=e("p",null,[e("code",null,"\\d+"),t(" 匹配 1 个或更多连续的数字")],-1)),a(o,{text:"123, transition, 02, family, 1",regex:"\\d+"}),d[9]||(d[9]=e("blockquote",null,[e("p",null,[t("这里的 "),e("code",null,"+"),t(" 是和 "),e("code",null,"*"),t(" 类似的元字符，不同的是 "),e("code",null,"*"),t(" 匹配重复任意次（可能是 0 次），而 "),e("code",null,"+"),t(" 则匹配重复 1 次或更多次。")])],-1)),d[10]||(d[10]=e("p",null,[e("code",null,"\\b\\w{6}\\b"),t(" 匹配刚好六个字符的单词")],-1)),a(o,{text:"typeof, start, name, family, jk, 烟火里的尘埃, 小情歌",regex:"\\b\\w{6}\\b"}),d[11]||(d[11]=l('<h3 id="常用的元字符" tabindex="-1">常用的元字符 <a class="header-anchor" href="#常用的元字符" aria-label="Permalink to &quot;常用的元字符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除换行符以外任意字符</td></tr><tr><td><code>\\w</code></td><td>匹配字母、数字或下划线</td></tr><tr><td><code>\\s</code></td><td>匹配任意的空白符</td></tr><tr><td><code>\\d</code></td><td>匹配数字</td></tr><tr><td><code>\\b</code></td><td>匹配单词的开始或结束</td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符 <code>^</code>（和数字 6 在同一个键位上的符号）和 <code>$</code> 都匹配一个位置，这和 <code>\\b</code> 有点类似。<code>^</code> 匹配你要用来查找的字符串的开头，<code>$</code> 匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的 QQ 号必须为 5 位到 12 位数字时，可以使用：<code>^\\d{5,12}$</code>，如下</p>',3)),a(o,{text:"12345",regex:"^\\d{5,12}$"}),d[12]||(d[12]=l("<blockquote><p>这里的 <code>{5,12}</code> 表示重复的次数不能少于 5 次，不能多于 12 次，否则都不匹配。</p></blockquote><p>它们（<code>^</code>、<code>$</code>）和 <code>\\b</code> 最大的区别就是，不能多次重复，必须是一段完整字符串的开头和结尾，假如要匹配一段字符串中的内容，还是需要 <code>\\b</code>，如下：</p><p>使用 <code>^</code>、<code>$</code></p>",3)),a(o,{text:"12345, 000, 1234567, 222, r12345, 12345t67",regex:"^\\d{5,12}$"}),d[13]||(d[13]=e("p",null,[t("使用 "),e("code",null,"\\b")],-1)),a(o,{text:"12345, 000, 1234567, 222, r12345, 12345t67",regex:"\\b\\d{5,12}\\b"}),d[14]||(d[14]=l('<h2 id="字符转义" tabindex="-1">字符转义 <a class="header-anchor" href="#字符转义" aria-label="Permalink to &quot;字符转义&quot;">​</a></h2><p>如果你想查找元字符本身的话，比如你查找 <code>.</code>，或者 <code>*</code>，就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 <code>\\</code> 来取消这些字符的特殊意义。因此，你应该使用 <code>\\.</code> 和 <code>\\*</code>。当然，要查找 <code>\\</code> 本身，你也得用 <code>\\\\</code>.</p><p>例如：<code>deerchao\\.cn</code> 匹配 <code>deerchao.cn</code>，<code>C:\\\\Windows</code> 匹配 <code>C:\\Windows</code></p><h2 id="重复" tabindex="-1">重复 <a class="header-anchor" href="#重复" aria-label="Permalink to &quot;重复&quot;">​</a></h2><p>你已经看过了前面的 <code>*</code>，<code>+</code>，<code>{2}</code>，<code>{5,12}</code> 这几个匹配重复的方式了。下面是正则表达式中所有的限定符</p><h3 id="常用的限定符" tabindex="-1">常用的限定符 <a class="header-anchor" href="#常用的限定符" aria-label="Permalink to &quot;常用的限定符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>重复零次或更多次</td></tr><tr><td><code>+</code></td><td>重复一次或更多次</td></tr><tr><td><code>?</code></td><td>重复零次或一次</td></tr><tr><td><code>{n}</code></td><td>重复 n 次</td></tr><tr><td><code>{n,}</code></td><td>重复 n 次或更多次</td></tr><tr><td><code>{n,m}</code></td><td>重复 n 到 m 次</td></tr></tbody></table><p>下面是一些使用重复的例子：</p><p><code>Windows\\d+</code> 匹配 Windows 后面跟 1 个或更多数字</p>',9)),a(o,{text:`WindowsXP
Windows7
Windows10`,regex:"Windows\\d+"}),d[15]||(d[15]=e("p",null,[e("code",null,"^\\w+"),t(" 匹配一行的第一个单词（或整个字符串的第一个单词，具体匹配哪个意思得看选项设置）")],-1)),a(o,{text:"Just to find,to find my samurai.",regex:"^\\w+"}),d[16]||(d[16]=e("h2",{id:"字符类",tabindex:"-1"},[t("字符类 "),e("a",{class:"header-anchor",href:"#字符类","aria-label":'Permalink to "字符类"'},"​")],-1)),d[17]||(d[17]=e("p",null,"要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？",-1)),d[18]||(d[18]=e("p",null,[t("很简单，你只需要在方括号里列出它们就行了，比如 "),e("code",null,"[aeiou]"),t(" 就匹配任何一个英文元音字母")],-1)),a(o,{text:"Sinister faces, growing curses.",regex:"[aeiou]"}),d[19]||(d[19]=e("p",null,[e("code",null,"[.?!]"),t(" 匹配标点符号("),e("code",null,"."),t(" 或 "),e("code",null,"?"),t(" 或 "),e("code",null,"!"),t(")。")],-1)),a(o,{text:`Who are you?
Where are you from?
where are you going?
My name is Tang Sanzang!
Coming from Dongtu Datang.
Go to the West to learn the scriptures.`,regex:"[.?!]"}),d[20]||(d[20]=l("<p>我们也可以轻松地指定一个字符范围，像 <code>[0-9]</code> 代表的含意与 <code>\\d</code> 就是完全一致的：一位数字；同理 <code>[a-z0-9A-Z_]</code> 也完全等同于 <code>\\w</code>（在 JavaScript 中 <code>\\w</code> 不包括汉字，但其他语言可能有所不同）。</p><p>下面看一个更复杂的表达式：<code>\\(?0\\d{2}[) -]?\\d{8}</code>。</p>",2)),a(o,{text:"(010)88886666, 452-19980000, 022-22334455, 1721234567, 02912345678",regex:"\\(?0\\d{2}[) -]?\\d{8}"}),d[21]||(d[21]=l('<p>这个表达式可以匹配几种格式的电话号码，像 <code>(010)88886666</code>，或 <code>022-22334455</code>，或 <code>02912345678</code> 等。我们对它进行一些分析吧：首先是一个转义字符 <code>\\(</code>，它能出现 0 次或 1 次 <code>?</code> ，然后是一个 0，后面跟着 2 个数字 <code>\\d{2}</code>，然后是 <code>)</code> 或 <code>-</code> 或 空格 中的一个，它出现 1 次或不出现 <code>?</code>，最后是 8 个数字 <code>\\d{8}</code> 。</p><h2 id="分枝条件" tabindex="-1">分枝条件 <a class="header-anchor" href="#分枝条件" aria-label="Permalink to &quot;分枝条件&quot;">​</a></h2><p>不幸的是，刚才那个表达式也能匹配 <code>010)12345678</code> 或 <code>(022-87654321</code> 这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 <code>|</code> 把不同的规则分隔开。听不明白？没关系，看例子：</p><p><code>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}</code> 这个表达式能匹配两种以连字号分隔的电话号码：一种是 3 位区号，8 位本地号（如<code>010-12345678</code>），一种是 4 位区号，7 位本地号（<code>0376-2233445</code>）。</p>',4)),a(o,{text:"010-12345678, 452-19980000, 0376-2233445, 1721234567",regex:"0\\d{2}-\\d{8}|0\\d{3}-\\d{7}"}),d[22]||(d[22]=e("p",null,[e("code",null,"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}"),t(" 这个表达式匹配 3 位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持 4 位区号的。")],-1)),a(o,{text:"010-12345678, 010 12345678, (010)12345678, (010) 12345678",regex:"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}"}),d[23]||(d[23]=e("p",null,"PS：🤔 那我来试试 4 位区号",-1)),a(o,{text:`010-12345678, 010 12345678, (010)12345678, (010) 12345678
0222-1234567, 0222 1234567, (0222)1234567, (0222) 1234567`,regex:"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}|\\(0\\d{3}\\)[- ]?\\d{7}|0\\d{3}[- ]?\\d{7}"}),d[24]||(d[24]=e("p",null,[e("code",null,"\\d{5}-\\d{4}|\\d{5}"),t(" 这个表达式用于匹配美国的邮政编码。美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成 "),e("code",null,"\\d{5}|\\d{5}-\\d{4}"),t(" 的话，那么就只会匹配 5 位的邮编（以及 9 位邮编的前 5 位）。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。如下")],-1)),d[25]||(d[25]=e("p",null,"正确用法：",-1)),a(o,{text:"12345-1234, 12345",regex:"\\d{5}-\\d{4}|\\d{5}"}),d[26]||(d[26]=e("p",null,"错误用法（顺序错误）：",-1)),a(o,{text:"12345-1234, 12345",regex:"\\d{5}|\\d{5}-\\d{4}"}),d[27]||(d[27]=e("blockquote",null,[e("p",null,[t("关于错误用法：其实就是，如果先匹配了前五位，后面匹配规则就从 "),e("code",null,"-"),t(" 开始了，所以自然也没有满足 9 位邮编的了。")])],-1)),d[28]||(d[28]=e("h2",{id:"分组",tabindex:"-1"},[t("分组 "),e("a",{class:"header-anchor",href:"#分组","aria-label":'Permalink to "分组"'},"​")],-1)),d[29]||(d[29]=e("p",null,"我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。",-1)),d[30]||(d[30]=e("p",null,[e("code",null,"(\\d{1,3}\\.){3}\\d{1,3}"),t(" 是一个简单的IP地址匹配表达式")],-1)),a(o,{text:"192.168.123.123, 192.001.002,",regex:"(\\d{1,3}\\.){3}\\d{1,3}"}),d[31]||(d[31]=l('<p>要理解这个表达式也不难，按照以下顺序分析：<code>\\d{1,3}</code> 匹配 1 到 3 位的数字，<code>(\\d{1,3}\\.){3}</code> 匹配三位数字加上一个英文句号（这个整体也就是这个分组）重复 3 次，最后再加上一个一到三位的数字 <code>\\d{1,3}</code> 。</p><p>不幸的是，它也将匹配 256.300.888.999 这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的 IP 地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</span></span></code></pre></div><p>理解这个表达式的关键是理解 <code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code>，这里我就不细说了，你自己应该能分析得出来它的意义。</p><blockquote><p>IP 地址中每个数字都不能大于 255. 经常有人问我， 01.02.03.04 这样前面带有 0 的数字, 是不是正确的 IP 地址呢？答案是: 是的， IP 地址里的数字可以包含有前导 0 (leading zeroes)。</p></blockquote><h2 id="反义" tabindex="-1">反义 <a class="header-anchor" href="#反义" aria-label="Permalink to &quot;反义&quot;">​</a></h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p><h3 id="常用的反义代码" tabindex="-1">常用的反义代码 <a class="header-anchor" href="#常用的反义代码" aria-label="Permalink to &quot;常用的反义代码&quot;">​</a></h3><table tabindex="0"><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>\\W</code></td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td><code>\\S</code></td><td>匹配任意不是空白符的字符</td></tr><tr><td><code>\\D</code></td><td>匹配任意非数字的字符</td></tr><tr><td><code>\\B</code></td><td>匹配不是单词开头或结束的位置</td></tr><tr><td><code>[^x]</code></td><td>匹配除了x以外的任意字符</td></tr><tr><td><code>[^aeiou]</code></td><td>匹配除了 aeiou 这几个字母以外的任意字符</td></tr></tbody></table><p>例子：</p><p>例1：<code>\\S+</code> 匹配不包含空白符的字符串</p>',11)),a(o,{text:"async await try cache",regex:"\\S+"}),d[32]||(d[32]=l('<p>例2：<code>&lt;a[^&gt;]+&gt;</code> 匹配用尖括号括起来的以 a 开头的字符串。</p><h2 id="后向引用" tabindex="-1">后向引用 <a class="header-anchor" href="#后向引用" aria-label="Permalink to &quot;后向引用&quot;">​</a></h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。</p><div class="info custom-block"><p class="custom-block-title">呃… 其实，组号分配还不像我刚说得那么简单：</p><ul><li>分组 0 对应整个正则表达式。</li><li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配，因此所有命名组的组号都大于未命名的组号。</li><li>你可以使用 <code>(?:exp)</code> 这样的语法来剥夺一个分组对组号分配的参与权。</li></ul></div><p>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\\1</code> 代表分组 1 匹配的文本。难以理解？请看示例：</p><p><code>\\b(\\w+)\\b\\s+\\1\\b</code> 可以用来匹配重复的单词，像 go go, 或者 kitty kitty，如下</p>',6)),a(o,{text:"go go, kitty kitty, give me",regex:"\\b(\\w+)\\b\\s+\\1\\b"}),d[33]||(d[33]=l('<p>这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 <code>\\b(\\w+)\\b</code>，这个单词会被捕获到编号为 1 的分组中，然后是 1 个或几个空白符 <code>\\s+</code>，最后是分组 1 中捕获的内容（也就是前面匹配的那个单词）<code>\\1</code>。</p><p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：<code>(?&lt;Word&gt;\\w+)</code> （或者把尖括号换成 <code>&#39;</code> 也行：<code>(?&#39;Word&#39;\\w+)</code>），这样就把 <code>\\w+</code> 的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用 <code>\\k&lt;Word&gt;</code> ，所以上一个例子也可以写成这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b</span></span></code></pre></div><p>示例如下</p><p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p><h3 id="常用分组语法"><a href="#常用分组语法" class="header-anchor">#</a> 常用分组语法</h3>',6)),d[34]||(d[34]=e("table",{cellspacing:"0"},[e("tbody",{class:"regex-table-tbody"},[e("tr",null,[e("th",{scope:"col"},"分类"),e("th",{scope:"col"},"代码/语法"),e("th",{scope:"col"},"说明")]),e("tr",null,[e("th",{rowspan:"3"},"捕获"),e("td",null,[e("code",{class:"code-word"},"(exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp，并捕获文本到自动命名的组里。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<name>exp)")]),e("td",null,[e("span",{class:"desc"},[t("匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 "),e("code",{class:"code-word"},"(?'name'exp)")]),t("。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?:exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp，不捕获匹配的文本，也不给此分组分配组号。")])]),e("tr",null,[e("th",{rowspan:"4"},"零宽断言"),e("td",null,[e("code",{class:"code-word"},"(?=exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp 前面的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<=exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp 后面的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?!exp)")]),e("td",null,[e("span",{class:"desc"},"匹配后面跟的不是 exp 的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<!exp)")]),e("td",null,[e("span",{class:"desc"},"匹配前面不是 exp 的位置。")])]),e("tr",null,[e("th",{rowspan:"1"},"注释"),e("td",null,[e("code",{class:"code-word"},"(?#comment)")]),e("td",null,[e("span",{class:"desc"},"这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读。")])])])],-1)),d[35]||(d[35]=l('<p>我们已经讨论了前两种语法。第三个 <code>(?:exp)</code> 不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”—— 好问题，你觉得为什么呢？</p><h2 id="零宽断言" tabindex="-1">零宽断言 <a class="header-anchor" href="#零宽断言" aria-label="Permalink to &quot;零宽断言&quot;">​</a></h2><blockquote><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p></blockquote><p>接下来的四个用于查找在某些内容（但并不包括这些内容）之前或之后的东西，也就是说它们像 <code>\\b</code>, <code>^</code>, <code>$</code> 那样用于指定一个位置，这个位置应该满足一定的条件（即断言），因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p><code>(?=exp)</code> 也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式 exp。</p><p>比如 <code>\\b\\w+(?=ing\\b)</code>，匹配以 ing 结尾的单词的前面部分（除了 ing 以外的部分），假如查找 I&#39;m singing while you&#39;re dancing. 它会匹配 sing 和 danc。</p>',6)),a(o,{text:"I'm singing while you're dancing.",regex:"\\b\\w+(?=ing\\b)"}),d[36]||(d[36]=e("p",null,[e("code",null,"(?<=exp)"),t(" 也叫"),e("strong",null,"零宽度正回顾后发断言"),t("，它断言自身出现的位置的前面能匹配表达式 exp。")],-1)),d[37]||(d[37]=e("p",null,[t("比如 "),e("code",null,"(?<=\\bre)\\w+\\b"),t(" 会匹配以 re 开头的单词的后半部分（除了 re 以外的部分），例如在查找 reading a book 时，它匹配 ading。")],-1)),a(o,{text:"reading a book",regex:"(?<=\\bre)\\w+\\b"}),d[38]||(d[38]=e("p",null,[t("假如你要给一个很长的数字中每三位间加一个逗号（当然是从右边加起了），你可以这样查找需要在前面和里面添加逗号的部分："),e("code",null,"((?<=\\d)\\d{3})+\\b"),t("，用它对 1234567890 进行查找时结果是 234567890 。")],-1)),a(o,{text:"1234567890",regex:"((?<=\\d)\\d{3})+\\b"}),d[39]||(d[39]=e("p",null,"下面这个例子同时使用了这两种断言：",-1)),d[40]||(d[40]=e("p",null,[e("code",null,"(?<=\\s)\\d+(?=\\s)"),t(" 匹配以空白符间隔的数字（再次强调，不包括这些空白符）。")],-1)),a(o,{text:"1 2 3 4 5, 123, 111 222 333 444 555",regex:"(?<=\\s)\\d+(?=\\s)"}),d[41]||(d[41]=l('<h2 id="负向零宽断言" tabindex="-1">负向零宽断言 <a class="header-anchor" href="#负向零宽断言" aria-label="Permalink to &quot;负向零宽断言&quot;">​</a></h2><p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法（反义）。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词，它里面出现了字母 q，但是 q 后面跟的不是字母 u，我们可以尝试这样：</p><p><code>\\b\\w*q[^u]\\w*\\b</code> 匹配包含后面不是字母 u 的字母 q 的单词。但是如果多做测试（或者你思维足够敏锐，直接就观察出来了），你会发现，如果 q 出现在单词的结尾的话，像匹配 <code>Iraq,Benq</code>，这个表达式就会出错。这是因为 <code>[^u]</code> 总要匹配一个字符，所以如果 q 是单词的最后一个字符的话，后面的 <code>[^u]</code> 将会匹配 q 后面的单词分隔符（可能是空格，或者是句号或其它的什么），后面的 <code>\\w*\\b</code> 将会匹配下一个单词，于是 <code>\\b\\w*q[^u]\\w*\\b</code> 就会匹配整个 <code>Iraq fighting</code>。</p>',3)),a(o,{text:"Iraq,Benq. Iraq fighting.",regex:"\\b\\w*q[^u]\\w*\\b"}),d[42]||(d[42]=e("p",null,[e("strong",null,"负向零宽断言"),t(" 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题："),e("code",null,"\\b\\w*q(?!u)\\w*\\b"),t("。")],-1)),a(o,{text:"Iraq,Benq. Iraq fighting.",regex:"\\b\\w*q(?!u)\\w*\\b"}),d[43]||(d[43]=e("p",null,[e("strong",null,"零宽度负预测先行断言"),t(),e("code",null,"(?!exp)"),t("，断言此位置的后面不能匹配表达式 exp。例如：")],-1)),d[44]||(d[44]=e("p",null,[e("code",null,"\\d{3}(?!\\d)"),t(" 匹配三位数字，而且这三位数字的后面不能是数字；")],-1)),a(o,{text:"123 1 1234 12 12345",regex:"\\d{3}(?!\\d)"}),d[45]||(d[45]=e("p",null,[e("code",null,"\\b((?!abc)\\w)+\\b"),t(" 匹配不包含连续字符串 abc 的单词。")],-1)),a(o,{text:"Yea isn't that the best thing? abc, abcde",regex:"\\b((?!abc)\\w)+\\b"}),d[46]||(d[46]=e("p",null,[t("同理，我们可以用 "),e("code",null,"(?<!exp)"),t(" ，"),e("strong",null,"零宽度负回顾后发断言"),t(" 来断言此位置的前面不能匹配表达式 exp："),e("code",null,"(?<![a-z])\\d{7}"),t(" 匹配前面不是小写字母的七位数字。")],-1)),a(o,{text:"R1234567, r1234567, 1234567, 12345678, r12345678",regex:"(?<![a-z])\\d{7}"}),d[47]||(d[47]=l(`<p>一个更复杂的例子：<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code> 匹配不包含属性的简单 HTML 标签内里的内容。<code>(?&lt;=&lt;(\\w+)&gt;)</code> 指定了这样的前缀：被尖括号括起来的单词（比如可能是 <code>&lt;b&gt;</code>），然后是 <code>.*</code> （任意的字符串），最后是一个后缀 <code>(?=&lt;\\/\\1&gt;)</code>。注意后缀里的 <code>\\/</code>，它用到了前面提过的字符转义；<code>\\1</code> 则是一个反向引用，引用的正是捕获的第一组，前面的 <code>(\\w+)</code> 匹配的内容。这样如果前缀实际上是 <code>&lt;b&gt;</code> 的话，后缀就是 <code>&lt;/b&gt;</code> 了。整个表达式匹配的是 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code> 之间的内容（再次提醒，不包括前缀和后缀本身）。</p><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><p>小括号的另一种用途是通过语法 <code>(?#comment)</code> 来包含注释。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</span></span></code></pre></div><p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在 <code>#</code> 后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(?&lt;=    # 断言要匹配的文本的前缀</span></span>
<span class="line"><span>&lt;(\\w+)&gt; # 查找尖括号括起来的内容</span></span>
<span class="line"><span>        # (即HTML/XML标签)</span></span>
<span class="line"><span>)       # 前缀结束</span></span>
<span class="line"><span>.*      # 匹配任意文本</span></span>
<span class="line"><span>(?=     # 断言要匹配的文本的后缀</span></span>
<span class="line"><span>&lt;\\/\\1&gt;  # 查找尖括号括起来的内容</span></span>
<span class="line"><span>        # 查找尖括号括起来的内容</span></span>
<span class="line"><span>)       # 后缀结束</span></span></code></pre></div><h2 id="贪婪与懒惰" tabindex="-1">贪婪与懒惰 <a class="header-anchor" href="#贪婪与懒惰" aria-label="Permalink to &quot;贪婪与懒惰&quot;">​</a></h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabcab 的话，它会匹配整个字符串 aabcab。这被称为贪婪匹配。</p>`,8)),a(o,{text:"aabcab",regex:"a.*b"}),d[48]||(d[48]=e("p",null,[t("有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 "),e("code",null,"?"),t("。这样 "),e("code",null,".*?"),t(" 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：")],-1)),d[49]||(d[49]=e("p",null,[e("code",null,"a.*?b"),t(" 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 aabcab 的话，它会匹配 aab（第一到第三个字符）和 ab（第五到第六个字符）。")],-1)),a(o,{text:"aabcab",regex:"a.*?b"}),d[50]||(d[50]=l(`<blockquote><p>为什么第一个匹配是 aab（第一到第三个字符）而不是 ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p></blockquote><h3 id="懒惰限定符" tabindex="-1">懒惰限定符 <a class="header-anchor" href="#懒惰限定符" aria-label="Permalink to &quot;懒惰限定符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复。</td></tr><tr><td><code>+?</code></td><td>重复 1 次或更多次，但尽可能少重复。</td></tr><tr><td><code>??</code></td><td>重复 0 次或 1 次，但尽可能少重复。</td></tr><tr><td><code>{n,m}?</code></td><td>重复 n 到 m 次，但尽可能少重复。</td></tr><tr><td><code>{n,}?</code></td><td>重复 n 次以上，但尽可能少重复。</td></tr></tbody></table><h2 id="处理选项" tabindex="-1">处理选项 <a class="header-anchor" href="#处理选项" aria-label="Permalink to &quot;处理选项&quot;">​</a></h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是 <code>.Net</code> 中常用的正则表达式选项：</p><blockquote><p>C# 中，你可以使用 <code>Regex(String, RegexOptions)</code> 构造函数来设置正则表达式的处理选项。如：<code>Regex regex = new Regex(@&quot;\\ba\\w{6}\\b&quot;, RegexOptions.IgnoreCase);</code></p></blockquote><h3 id="常用的处理选项" tabindex="-1">常用的处理选项 <a class="header-anchor" href="#常用的处理选项" aria-label="Permalink to &quot;常用的处理选项&quot;">​</a></h3><table tabindex="0"><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>IgnoreCase（忽略大小写）</td><td>匹配时不区分大小写。</td></tr><tr><td>Multiline（多行模式）</td><td>更改 <code>^</code> 和 <code>$</code> 的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。（在此模式下，<code>$</code> 的精确含意是：匹配 <code>\\n</code> 之前的位置以及字符串结束前的位置）</td></tr><tr><td>Singleline（单行模式）</td><td>更改 <code>.</code> 的含义，使它与每一个字符匹配（包括换行符 <code>\\n</code>）。</td></tr><tr><td>IgnorePatternWhitespace（忽略空白）</td><td>忽略表达式中的非转义空白并启用由 <code>#</code> 标记的注释。</td></tr><tr><td>ExplicitCapture（显式捕获）</td><td>仅捕获已被显式命名的组。</td></tr></tbody></table><p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 dotAll，意为点可以匹配所有字符，然而在指定该选项时，用的还是 Singleline 的首字母 s 。</p><blockquote><p>目前（2019/06），只有基于 Webkit/Chromium 的浏览器（如 Chrome，Safari等）才支持 dotAll 选项。</p></blockquote><h2 id="平衡组-递归匹配" tabindex="-1">平衡组/递归匹配 <a class="header-anchor" href="#平衡组-递归匹配" aria-label="Permalink to &quot;平衡组/递归匹配&quot;">​</a></h2><p>有时我们需要匹配像 <code>( 100 * ( 50 + 15 ) )</code> 这样的可嵌套的层次性结构，这时简单地使用 <code>\\(.+\\)</code> 则只会匹配到最左边的左括号和最右边的右括号之间的内容（这里我们讨论的是贪婪模式，懒惰模式也有下面的问题）。假如原来的字符串里的左括号和右括号出现的次数不相等，比如 <code>( 5 / ( 3 + 2 ) ) )</code>，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p><p>为了避免 <code>(</code> 和 <code>\\(</code> 把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把 <code>xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy</code> 这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p><p>这里需要用到以下的语法构造：</p><ul><li><code>(?&#39;group&#39;)</code> 把捕获的内容命名为 group，并压入 <strong>堆栈(Stack)</strong>。</li><li><code>(?&#39;-group&#39;)</code> 从堆栈上弹出最后压入堆栈的名为 group 的捕获内容，如果堆栈本来为空，则本分组的匹配失败。</li><li><code>(?(group)yes|no)</code> 如果堆栈上存在以名为 group 的捕获内容的话，继续匹配 yes 部分的表达式，否则继续匹配 no 部分。</li><li><code>(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败。</li></ul><p>我们需要做的是每碰到了左括号，就在压入一个&quot;Open&quot;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空，如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯（放弃最前面或最后面的一些字符），尽量使整个表达式得到匹配。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;                    #最外层的左括号</span></span>
<span class="line"><span>  [^&lt;&gt;]*             #它后面非括号的内容</span></span>
<span class="line"><span>  (</span></span>
<span class="line"><span>      (</span></span>
<span class="line"><span>        (?&#39;Open&#39;&lt;)   #左括号，压入&quot;Open&quot;</span></span>
<span class="line"><span>        [^&lt;&gt;]*       #左括号后面的内容</span></span>
<span class="line"><span>      )+</span></span>
<span class="line"><span>      (</span></span>
<span class="line"><span>        (?&#39;-Open&#39;&gt;)  #右括号，弹出一个&quot;Open&quot;</span></span>
<span class="line"><span>        [^&lt;&gt;]*       #右括号后面的内容</span></span>
<span class="line"><span>      )+</span></span>
<span class="line"><span>  )*</span></span>
<span class="line"><span>  (?(Open)(?!))      #最外层的右括号前检查</span></span>
<span class="line"><span>                     #若还有未弹出的&quot;Open&quot;</span></span>
<span class="line"><span>                     #则匹配失败</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&gt;                    #最外层的右括号</span></span></code></pre></div>`,17))])}const _=n(r,[["render",i]]);export{q as __pageData,_ as default};
