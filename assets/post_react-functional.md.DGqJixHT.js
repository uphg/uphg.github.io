import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.BHpayLOB.js";const o=JSON.parse('{"title":"React 函数式编程的要点","description":"","frontmatter":{"title":"React 函数式编程的要点","date":"2024-10-17T01:06:52.000Z","tags":["React","函数式编程"],"prev":{"text":"Python 的安装与开发环境构建（Windows）","link":"/post/py-install"},"next":{"text":"Git 命令手册","link":"/post/git-book"}},"headers":[],"relativePath":"post/react-functional.md","filePath":"post/react-functional.md","lastUpdated":1729131695000}'),n={name:"post/react-functional.md"};function l(h,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h2 id="react-函数式编程的核心理念" tabindex="-1">React 函数式编程的核心理念 <a class="header-anchor" href="#react-函数式编程的核心理念" aria-label="Permalink to &quot;React 函数式编程的核心理念&quot;">​</a></h2><p>在使用 React 进行函数式编程时，有几个关键点需要牢记：</p><ol><li><strong>关注依赖关系，而非执行顺序</strong>：函数式编程更注重组件和函数之间的依赖关系，而不是代码的执行顺序。</li><li><strong>隔离副作用</strong>：函数式编程的目标是将副作用（如数据获取、DOM 操作等）限制在小范围内，防止它们影响整体程序的纯度。</li><li><strong>保持纯函数</strong>：在 React 应用中，除了 useEffect 钩子内的代码，其他部分应该尽量保持纯函数的特性。这意味着给定相同的输入，总是产生相同的输出，且不产生副作用。</li></ol><h2 id="实践示例" tabindex="-1">实践示例 <a class="header-anchor" href="#实践示例" aria-label="Permalink to &quot;实践示例&quot;">​</a></h2><p>假设我们需要根据不同用户返回不同的 id ，一个好的做法是使用自定义 Hook：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span></code></pre></div><p>请问 useUser 怎么实现？</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useUser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userCache[id])</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (stale) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      ajax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/api/user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userCache[id] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.user, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data.user))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // do nothing</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [id])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [user, setUser]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种方式将数据获取的逻辑封装在 <code>useUser</code> Hook 中，保持了组件代码的简洁和纯度。</p><h2 id="避免直接使用-useeffect" tabindex="-1">避免直接使用 useEffect <a class="header-anchor" href="#避免直接使用-useeffect" aria-label="Permalink to &quot;避免直接使用 useEffect&quot;">​</a></h2><p>在组件中直接使用 useEffect 可能导致纯代码和不纯代码混合，影响代码的可维护性。相反，我们应该：</p><ul><li>将 useEffect 逻辑封装在自定义 Hook 中。</li><li>使用像 SWR 或 React Query 这样的数据获取库，它们内部已经处理了副作用。</li></ul><h2 id="react-开发者技能评估" tabindex="-1">React 开发者技能评估 <a class="header-anchor" href="#react-开发者技能评估" aria-label="Permalink to &quot;React 开发者技能评估&quot;">​</a></h2><p>在面试 React 开发者时，询问他们如何获取数据可以很好地评估其技能水平：</p><ol><li>无法回答：可能对 React 不太熟悉。</li><li>使用 useState 和 useEffect：基本了解 React，但经验有限。</li><li>封装自定义 Hook：有实际项目经验。</li><li>使用 SWR 或 React Query：了解现代 React 开发最佳实践。</li><li>了解 use Hook 和 Suspense：对 React 新特性有深入理解，经验丰富。</li></ol><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p>React 函数式编程强调代码的纯度、可预测性和可维护性。通过正确使用 Hooks、自定义 Hook 和现代数据获取库，我们可以编写出更加清晰、高效的 React 应用。</p>`,17)]))}const c=i(n,[["render",l]]);export{o as __pageData,c as default};
