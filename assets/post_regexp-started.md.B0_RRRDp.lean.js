import{_ as n,C as s,c as p,o as c,ag as l,G as a,j as e,a as t}from"./chunks/framework.BHpayLOB.js";const q=JSON.parse('{"title":"正则表达式入门","description":"","frontmatter":{"title":"正则表达式入门","tags":["regex"],"date":"2021-02-12T10:15:22.000Z","prev":{"text":"堆叠上下文","link":"/post/stacking-context"},"next":{"text":"DOM 操作跨线程","link":"/post/dom-operate-across-threads"}},"headers":[],"relativePath":"post/regexp-started.md","filePath":"post/regexp-started.md","lastUpdated":1714895308000}'),r={name:"post/regexp-started.md"};function i(u,d,b,g,x,h){const o=s("t-regexp-demo");return c(),p("div",null,[d[0]||(d[0]=l("",6)),a(o,{text:"him, hi, history, high",regex:"\\bhi\\b"}),d[1]||(d[1]=e("p",null,"假如要找 hi 后面不远处跟着的一个 Lucy 的内容，如下",-1)),a(o,{text:"him, hi, reset, Lucy, high",regex:"\\bhi\\b.*\\bLucy\\b"}),d[2]||(d[2]=e("p",null,[e("code",null,"."),t(" 是另一个元字符，匹配"),e("strong",null,"除了换行符以外的任意字符"),t("。")],-1)),d[3]||(d[3]=e("p",null,[e("code",null,"*"),t(" 同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定 "),e("code",null,"*"),t(),e("strong",null,"前边的内容可以连续重复使用任意次以使整个表达式得到匹配"),t("。")],-1)),d[4]||(d[4]=e("p",null,"将元字符与其他字符组合起来，就可以组成更强大的正则表达式，如下",-1)),a(o,{text:`012-34567890
123-45678901`,regex:"0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d"}),d[5]||(d[5]=e("p",null,[t("这里的 "),e("code",null,"\\d"),t(" 是个新的元字符，匹配一位数字（0，或1，或2，或…）。")],-1)),d[6]||(d[6]=e("p",null,[t("为了避免多次重复，可以使用 "),e("code",null,"{}"),t(" 简写上面的正则，如下")],-1)),a(o,{text:`012-34567890
123-45678901`,regex:"0\\d{2}-\\d{8}"}),d[7]||(d[7]=l("",5)),a(o,{text:"animation, transition, all, family",regex:"\\ba\\w*\\b"}),d[8]||(d[8]=e("p",null,[e("code",null,"\\d+"),t(" 匹配 1 个或更多连续的数字")],-1)),a(o,{text:"123, transition, 02, family, 1",regex:"\\d+"}),d[9]||(d[9]=e("blockquote",null,[e("p",null,[t("这里的 "),e("code",null,"+"),t(" 是和 "),e("code",null,"*"),t(" 类似的元字符，不同的是 "),e("code",null,"*"),t(" 匹配重复任意次（可能是 0 次），而 "),e("code",null,"+"),t(" 则匹配重复 1 次或更多次。")])],-1)),d[10]||(d[10]=e("p",null,[e("code",null,"\\b\\w{6}\\b"),t(" 匹配刚好六个字符的单词")],-1)),a(o,{text:"typeof, start, name, family, jk, 烟火里的尘埃, 小情歌",regex:"\\b\\w{6}\\b"}),d[11]||(d[11]=l("",3)),a(o,{text:"12345",regex:"^\\d{5,12}$"}),d[12]||(d[12]=l("",3)),a(o,{text:"12345, 000, 1234567, 222, r12345, 12345t67",regex:"^\\d{5,12}$"}),d[13]||(d[13]=e("p",null,[t("使用 "),e("code",null,"\\b")],-1)),a(o,{text:"12345, 000, 1234567, 222, r12345, 12345t67",regex:"\\b\\d{5,12}\\b"}),d[14]||(d[14]=l("",9)),a(o,{text:`WindowsXP
Windows7
Windows10`,regex:"Windows\\d+"}),d[15]||(d[15]=e("p",null,[e("code",null,"^\\w+"),t(" 匹配一行的第一个单词（或整个字符串的第一个单词，具体匹配哪个意思得看选项设置）")],-1)),a(o,{text:"Just to find,to find my samurai.",regex:"^\\w+"}),d[16]||(d[16]=e("h2",{id:"字符类",tabindex:"-1"},[t("字符类 "),e("a",{class:"header-anchor",href:"#字符类","aria-label":'Permalink to "字符类"'},"​")],-1)),d[17]||(d[17]=e("p",null,"要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？",-1)),d[18]||(d[18]=e("p",null,[t("很简单，你只需要在方括号里列出它们就行了，比如 "),e("code",null,"[aeiou]"),t(" 就匹配任何一个英文元音字母")],-1)),a(o,{text:"Sinister faces, growing curses.",regex:"[aeiou]"}),d[19]||(d[19]=e("p",null,[e("code",null,"[.?!]"),t(" 匹配标点符号("),e("code",null,"."),t(" 或 "),e("code",null,"?"),t(" 或 "),e("code",null,"!"),t(")。")],-1)),a(o,{text:`Who are you?
Where are you from?
where are you going?
My name is Tang Sanzang!
Coming from Dongtu Datang.
Go to the West to learn the scriptures.`,regex:"[.?!]"}),d[20]||(d[20]=l("",2)),a(o,{text:"(010)88886666, 452-19980000, 022-22334455, 1721234567, 02912345678",regex:"\\(?0\\d{2}[) -]?\\d{8}"}),d[21]||(d[21]=l("",4)),a(o,{text:"010-12345678, 452-19980000, 0376-2233445, 1721234567",regex:"0\\d{2}-\\d{8}|0\\d{3}-\\d{7}"}),d[22]||(d[22]=e("p",null,[e("code",null,"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}"),t(" 这个表达式匹配 3 位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持 4 位区号的。")],-1)),a(o,{text:"010-12345678, 010 12345678, (010)12345678, (010) 12345678",regex:"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}"}),d[23]||(d[23]=e("p",null,"PS：🤔 那我来试试 4 位区号",-1)),a(o,{text:`010-12345678, 010 12345678, (010)12345678, (010) 12345678
0222-1234567, 0222 1234567, (0222)1234567, (0222) 1234567`,regex:"\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}|\\(0\\d{3}\\)[- ]?\\d{7}|0\\d{3}[- ]?\\d{7}"}),d[24]||(d[24]=e("p",null,[e("code",null,"\\d{5}-\\d{4}|\\d{5}"),t(" 这个表达式用于匹配美国的邮政编码。美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成 "),e("code",null,"\\d{5}|\\d{5}-\\d{4}"),t(" 的话，那么就只会匹配 5 位的邮编（以及 9 位邮编的前 5 位）。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。如下")],-1)),d[25]||(d[25]=e("p",null,"正确用法：",-1)),a(o,{text:"12345-1234, 12345",regex:"\\d{5}-\\d{4}|\\d{5}"}),d[26]||(d[26]=e("p",null,"错误用法（顺序错误）：",-1)),a(o,{text:"12345-1234, 12345",regex:"\\d{5}|\\d{5}-\\d{4}"}),d[27]||(d[27]=e("blockquote",null,[e("p",null,[t("关于错误用法：其实就是，如果先匹配了前五位，后面匹配规则就从 "),e("code",null,"-"),t(" 开始了，所以自然也没有满足 9 位邮编的了。")])],-1)),d[28]||(d[28]=e("h2",{id:"分组",tabindex:"-1"},[t("分组 "),e("a",{class:"header-anchor",href:"#分组","aria-label":'Permalink to "分组"'},"​")],-1)),d[29]||(d[29]=e("p",null,"我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。",-1)),d[30]||(d[30]=e("p",null,[e("code",null,"(\\d{1,3}\\.){3}\\d{1,3}"),t(" 是一个简单的IP地址匹配表达式")],-1)),a(o,{text:"192.168.123.123, 192.001.002,",regex:"(\\d{1,3}\\.){3}\\d{1,3}"}),d[31]||(d[31]=l("",11)),a(o,{text:"async await try cache",regex:"\\S+"}),d[32]||(d[32]=l("",6)),a(o,{text:"go go, kitty kitty, give me",regex:"\\b(\\w+)\\b\\s+\\1\\b"}),d[33]||(d[33]=l("",6)),d[34]||(d[34]=e("table",{cellspacing:"0"},[e("tbody",{class:"regex-table-tbody"},[e("tr",null,[e("th",{scope:"col"},"分类"),e("th",{scope:"col"},"代码/语法"),e("th",{scope:"col"},"说明")]),e("tr",null,[e("th",{rowspan:"3"},"捕获"),e("td",null,[e("code",{class:"code-word"},"(exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp，并捕获文本到自动命名的组里。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<name>exp)")]),e("td",null,[e("span",{class:"desc"},[t("匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 "),e("code",{class:"code-word"},"(?'name'exp)")]),t("。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?:exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp，不捕获匹配的文本，也不给此分组分配组号。")])]),e("tr",null,[e("th",{rowspan:"4"},"零宽断言"),e("td",null,[e("code",{class:"code-word"},"(?=exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp 前面的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<=exp)")]),e("td",null,[e("span",{class:"desc"},"匹配 exp 后面的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?!exp)")]),e("td",null,[e("span",{class:"desc"},"匹配后面跟的不是 exp 的位置。")])]),e("tr",null,[e("td",null,[e("code",{class:"code-word"},"(?<!exp)")]),e("td",null,[e("span",{class:"desc"},"匹配前面不是 exp 的位置。")])]),e("tr",null,[e("th",{rowspan:"1"},"注释"),e("td",null,[e("code",{class:"code-word"},"(?#comment)")]),e("td",null,[e("span",{class:"desc"},"这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读。")])])])],-1)),d[35]||(d[35]=l("",6)),a(o,{text:"I'm singing while you're dancing.",regex:"\\b\\w+(?=ing\\b)"}),d[36]||(d[36]=e("p",null,[e("code",null,"(?<=exp)"),t(" 也叫"),e("strong",null,"零宽度正回顾后发断言"),t("，它断言自身出现的位置的前面能匹配表达式 exp。")],-1)),d[37]||(d[37]=e("p",null,[t("比如 "),e("code",null,"(?<=\\bre)\\w+\\b"),t(" 会匹配以 re 开头的单词的后半部分（除了 re 以外的部分），例如在查找 reading a book 时，它匹配 ading。")],-1)),a(o,{text:"reading a book",regex:"(?<=\\bre)\\w+\\b"}),d[38]||(d[38]=e("p",null,[t("假如你要给一个很长的数字中每三位间加一个逗号（当然是从右边加起了），你可以这样查找需要在前面和里面添加逗号的部分："),e("code",null,"((?<=\\d)\\d{3})+\\b"),t("，用它对 1234567890 进行查找时结果是 234567890 。")],-1)),a(o,{text:"1234567890",regex:"((?<=\\d)\\d{3})+\\b"}),d[39]||(d[39]=e("p",null,"下面这个例子同时使用了这两种断言：",-1)),d[40]||(d[40]=e("p",null,[e("code",null,"(?<=\\s)\\d+(?=\\s)"),t(" 匹配以空白符间隔的数字（再次强调，不包括这些空白符）。")],-1)),a(o,{text:"1 2 3 4 5, 123, 111 222 333 444 555",regex:"(?<=\\s)\\d+(?=\\s)"}),d[41]||(d[41]=l("",3)),a(o,{text:"Iraq,Benq. Iraq fighting.",regex:"\\b\\w*q[^u]\\w*\\b"}),d[42]||(d[42]=e("p",null,[e("strong",null,"负向零宽断言"),t(" 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题："),e("code",null,"\\b\\w*q(?!u)\\w*\\b"),t("。")],-1)),a(o,{text:"Iraq,Benq. Iraq fighting.",regex:"\\b\\w*q(?!u)\\w*\\b"}),d[43]||(d[43]=e("p",null,[e("strong",null,"零宽度负预测先行断言"),t(),e("code",null,"(?!exp)"),t("，断言此位置的后面不能匹配表达式 exp。例如：")],-1)),d[44]||(d[44]=e("p",null,[e("code",null,"\\d{3}(?!\\d)"),t(" 匹配三位数字，而且这三位数字的后面不能是数字；")],-1)),a(o,{text:"123 1 1234 12 12345",regex:"\\d{3}(?!\\d)"}),d[45]||(d[45]=e("p",null,[e("code",null,"\\b((?!abc)\\w)+\\b"),t(" 匹配不包含连续字符串 abc 的单词。")],-1)),a(o,{text:"Yea isn't that the best thing? abc, abcde",regex:"\\b((?!abc)\\w)+\\b"}),d[46]||(d[46]=e("p",null,[t("同理，我们可以用 "),e("code",null,"(?<!exp)"),t(" ，"),e("strong",null,"零宽度负回顾后发断言"),t(" 来断言此位置的前面不能匹配表达式 exp："),e("code",null,"(?<![a-z])\\d{7}"),t(" 匹配前面不是小写字母的七位数字。")],-1)),a(o,{text:"R1234567, r1234567, 1234567, 12345678, r12345678",regex:"(?<![a-z])\\d{7}"}),d[47]||(d[47]=l("",8)),a(o,{text:"aabcab",regex:"a.*b"}),d[48]||(d[48]=e("p",null,[t("有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 "),e("code",null,"?"),t("。这样 "),e("code",null,".*?"),t(" 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：")],-1)),d[49]||(d[49]=e("p",null,[e("code",null,"a.*?b"),t(" 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 aabcab 的话，它会匹配 aab（第一到第三个字符）和 ab（第五到第六个字符）。")],-1)),a(o,{text:"aabcab",regex:"a.*?b"}),d[50]||(d[50]=l("",17))])}const _=n(r,[["render",i]]);export{q as __pageData,_ as default};
